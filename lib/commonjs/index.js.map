{"version":3,"sources":["index.tsx"],"names":["emptyCustomTabsPackages","defaultBrowserPackage","undefined","preferredBrowserPackage","browserPackages","servicePackages","getCustomTabsSupportingBrowsersAsync","NativeWebBrowser","UnavailabilityError","Platform","OS","warmUpAsync","browserPackage","mayInitWithUrlAsync","url","coolDownAsync","browserLocked","openBrowserAsync","browserParams","__DEV__","console","warn","type","WebBrowserResultType","LOCKED","result","dismissBrowser","openAuthSessionAsync","redirectUrl","options","_authSessionIsNativelySupported","includes","_openAuthSessionPolyfillAsync","dismissAuthSession","maybeCompleteAuthSession","message","versionNumber","parseInt","String","Version","_redirectHandler","_onWebBrowserCloseAndroid","_isAppStateAvailable","AppState","currentState","_onAppStateChangeAndroid","state","_openBrowserAndWaitAndroidAsync","startUrl","appStateChangedToActive","Promise","resolve","stateChangeSubscription","addEventListener","CANCEL","e","remove","DISMISS","returnUrl","Error","race","_waitForRedirectAsync","_stopWaitingForRedirect","Linking","removeEventListener","event","startsWith"],"mappings":"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","sourcesContent":["import { AppState, AppStateStatus, Linking, Platform } from 'react-native';\nimport NativeWebBrowser from './NativeWebBrowser';\nimport {\n  RedirectEvent,\n  WebBrowserAuthSessionResult,\n  WebBrowserCompleteAuthSessionOptions,\n  WebBrowserCompleteAuthSessionResult,\n  WebBrowserCoolDownResult,\n  WebBrowserCustomTabsResults,\n  WebBrowserMayInitWithUrlResult,\n  WebBrowserOpenOptions,\n  WebBrowserRedirectResult,\n  WebBrowserResult,\n  WebBrowserResultType,\n  WebBrowserWarmUpResult,\n  WebBrowserWindowFeatures,\n  WebBrowserPresentationStyle,\n  AuthSessionOpenOptions,\n  UnavailabilityError,\n} from './WebBrowser.types';\n\nexport {\n  WebBrowserAuthSessionResult,\n  WebBrowserCompleteAuthSessionOptions,\n  WebBrowserCompleteAuthSessionResult,\n  WebBrowserCoolDownResult,\n  WebBrowserCustomTabsResults,\n  WebBrowserMayInitWithUrlResult,\n  WebBrowserOpenOptions,\n  WebBrowserRedirectResult,\n  WebBrowserResult,\n  WebBrowserResultType,\n  WebBrowserWarmUpResult,\n  WebBrowserWindowFeatures,\n  WebBrowserPresentationStyle,\n  AuthSessionOpenOptions,\n};\n\nconst emptyCustomTabsPackages: WebBrowserCustomTabsResults = {\n  defaultBrowserPackage: undefined,\n  preferredBrowserPackage: undefined,\n  browserPackages: [],\n  servicePackages: [],\n};\n\n/**\n * Returns a list of applications package names supporting Custom Tabs, Custom Tabs\n * service, user chosen and preferred one. This may not be fully reliable, since it uses\n * `PackageManager.getResolvingActivities` under the hood. (For example, some browsers might not be\n * present in browserPackages list once another browser is set to default.)\n *\n * @return The promise which fulfils with [`WebBrowserCustomTabsResults`](#webbrowsercustomtabsresults) object.\n * @platform android\n */\nexport async function getCustomTabsSupportingBrowsersAsync(): Promise<WebBrowserCustomTabsResults> {\n  if (!NativeWebBrowser.getCustomTabsSupportingBrowsersAsync) {\n    throw new UnavailabilityError(\n      'WebBrowser',\n      'getCustomTabsSupportingBrowsersAsync'\n    );\n  }\n  if (Platform.OS !== 'android') {\n    return emptyCustomTabsPackages;\n  } else {\n    return await NativeWebBrowser.getCustomTabsSupportingBrowsersAsync();\n  }\n}\n\n/**\n * This method calls `warmUp` method on [CustomTabsClient](https://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#warmup(long))\n * for specified package.\n *\n * @param browserPackage Package of browser to be warmed up. If not set, preferred browser will be warmed.\n *\n * @return A promise which fulfils with `WebBrowserWarmUpResult` object.\n * @platform android\n */\nexport async function warmUpAsync(\n  browserPackage?: string\n): Promise<WebBrowserWarmUpResult> {\n  if (!NativeWebBrowser.warmUpAsync) {\n    throw new UnavailabilityError('WebBrowser', 'warmUpAsync');\n  }\n  if (Platform.OS !== 'android') {\n    return {};\n  } else {\n    return await NativeWebBrowser.warmUpAsync(browserPackage);\n  }\n}\n\n/**\n * This method initiates (if needed) [CustomTabsSession](https://developer.android.com/reference/android/support/customtabs/CustomTabsSession.html#maylaunchurl)\n * and calls its `mayLaunchUrl` method for browser specified by the package.\n *\n * @param url The url of page that is likely to be loaded first when opening browser.\n * @param browserPackage Package of browser to be informed. If not set, preferred\n * browser will be used.\n *\n * @return A promise which fulfils with `WebBrowserMayInitWithUrlResult` object.\n * @platform android\n */\nexport async function mayInitWithUrlAsync(\n  url: string,\n  browserPackage?: string\n): Promise<WebBrowserMayInitWithUrlResult> {\n  if (!NativeWebBrowser.mayInitWithUrlAsync) {\n    throw new UnavailabilityError('WebBrowser', 'mayInitWithUrlAsync');\n  }\n  if (Platform.OS !== 'android') {\n    return {};\n  } else {\n    return await NativeWebBrowser.mayInitWithUrlAsync(url, browserPackage);\n  }\n}\n\n/**\n * This methods removes all bindings to services created by [`warmUpAsync`](#webbrowserwarmupasyncbrowserpackage)\n * or [`mayInitWithUrlAsync`](#webbrowsermayinitwithurlasyncurl-browserpackage). You should call\n * this method once you don't need them to avoid potential memory leaks. However, those binding\n * would be cleared once your application is destroyed, which might be sufficient in most cases.\n *\n * @param browserPackage Package of browser to be cooled. If not set, preferred browser will be used.\n *\n * @return The promise which fulfils with ` WebBrowserCoolDownResult` when cooling is performed, or\n * an empty object when there was no connection to be dismissed.\n * @platform android\n */\nexport async function coolDownAsync(\n  browserPackage?: string\n): Promise<WebBrowserCoolDownResult> {\n  if (!NativeWebBrowser.coolDownAsync) {\n    throw new UnavailabilityError('WebBrowser', 'coolDownAsync');\n  }\n  if (Platform.OS !== 'android') {\n    return {};\n  } else {\n    return await NativeWebBrowser.coolDownAsync(browserPackage);\n  }\n}\n\nlet browserLocked = false;\n\n// @needsAudit\n/**\n * Opens the url with Safari in a modal on iOS using [`SFSafariViewController`](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller),\n * and Chrome in a new [custom tab](https://developer.chrome.com/multidevice/android/customtabs)\n * on Android. On iOS, the modal Safari will not share cookies with the system Safari. If you need\n * this, use [`openAuthSessionAsync`](#webbrowseropenauthsessionasyncurl-redirecturl-browserparams).\n *\n * @param url The url to open in the web browser.\n * @param browserParams A dictionary of key-value pairs.\n *\n * @return The promise behaves differently based on the platform.\n * On Android promise resolves with `{type: 'opened'}` if we were able to open browser.\n * On iOS:\n * - If the user closed the web browser, the Promise resolves with `{ type: 'cancel' }`.\n * - If the browser is closed using [`dismissBrowser`](#webbrowserdismissbrowser), the Promise resolves with `{ type: 'dismiss' }`.\n */\nexport async function openBrowserAsync(\n  url: string,\n  browserParams: WebBrowserOpenOptions = {}\n): Promise<WebBrowserResult> {\n  if (!NativeWebBrowser.openBrowserAsync) {\n    throw new UnavailabilityError('WebBrowser', 'openBrowserAsync');\n  }\n\n  if (browserLocked) {\n    // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n    // support it this makes the behavior predictable.\n    if (__DEV__) {\n      console.warn(\n        'Attempted to call WebBrowser.openBrowserAsync multiple times while already active. Only one WebBrowser controller can be active at any given time.'\n      );\n    }\n\n    return { type: WebBrowserResultType.LOCKED };\n  }\n  browserLocked = true;\n\n  let result: WebBrowserResult;\n  try {\n    result = await NativeWebBrowser.openBrowserAsync(url, browserParams);\n  } finally {\n    // WebBrowser session complete, unset lock\n    browserLocked = false;\n  }\n\n  return result;\n}\n\n/**\n * Dismisses the presented web browser.\n *\n * @return The `void` on successful attempt, or throws error, if dismiss functionality is not avaiable.\n * @platform ios\n */\nexport function dismissBrowser(): void {\n  if (!NativeWebBrowser.dismissBrowser) {\n    throw new UnavailabilityError('WebBrowser', 'dismissBrowser');\n  }\n  NativeWebBrowser.dismissBrowser();\n}\n\n/**\n * # On iOS:\n * Opens the url with Safari in a modal using `SFAuthenticationSession` on iOS 11 and greater,\n * and falling back on a `SFSafariViewController`. The user will be asked whether to allow the app\n * to authenticate using the given url.\n *\n * # On Android:\n * This will be done using a \"custom Chrome tabs\" browser, [AppState](../react-native/appstate/),\n * and [Linking](./linking/) APIs.\n *\n * # On web:\n * > This API can only be used in a secure environment (`https`). You can use expo `start:web --https`\n * to test this. Otherwise, an error with code [`ERR_WEB_BROWSER_CRYPTO`](#errwebbrowsercrypto) will be thrown.\n * This will use the browser's [`window.open()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/open) API.\n * - _Desktop_: This will create a new web popup window in the browser that can be closed later using `WebBrowser.maybeCompleteAuthSession()`.\n * - _Mobile_: This will open a new tab in the browser which can be closed using `WebBrowser.maybeCompleteAuthSession()`.\n *\n * How this works on web:\n * - A crypto state will be created for verifying the redirect.\n *   - This means you need to run with `expo start:web --https`\n * - The state will be added to the window's `localstorage`. This ensures that auth cannot complete\n *   unless it's done from a page running with the same origin as it was started.\n *   Ex: if `openAuthSessionAsync` is invoked on `https://localhost:19006`, then `maybeCompleteAuthSession`\n *   must be invoked on a page hosted from the origin `https://localhost:19006`. Using a different\n *   website, or even a different host like `https://128.0.0.*:19006` for example will not work.\n * - A timer will be started to check for every 1000 milliseconds (1 second) to detect if the window\n *   has been closed by the user. If this happens then a promise will resolve with `{ type: 'dismiss' }`.\n *\n * > On mobile web, Chrome and Safari will block any call to [`window.open()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/open)\n * which takes too long to fire after a user interaction. This method must be invoked immediately\n * after a user interaction. If the event is blocked, an error with code [`ERR_WEB_BROWSER_BLOCKED`](#errwebbrowserblocked) will be thrown.\n *\n * @param url The url to open in the web browser. This should be a login page.\n * @param redirectUrl _Optional_ - The url to deep link back into your app. By default, this will be [`Constants.linkingUrl`](./constants/#expoconstantslinkinguri).\n * @param options _Optional_ - An object extending the [`WebBrowserOpenOptions`](#webbrowseropenoptions).\n * If there is no native AuthSession implementation available (which is the case on Android)\n * these params will be used in the browser polyfill. If there is a native AuthSession implementation,\n * these params will be ignored.\n *\n * @return\n * - If the user does not permit the application to authenticate with the given url, the Promise fulfills with `{ type: 'cancel' }` object.\n * - If the user closed the web browser, the Promise fulfills with `{ type: 'cancel' }` object.\n * - If the browser is closed using [`dismissBrowser`](#webbrowserdismissbrowser),\n * the Promise fulfills with `{ type: 'dismiss' }` object.\n */\nexport async function openAuthSessionAsync(\n  url: string,\n  redirectUrl: string,\n  options: AuthSessionOpenOptions = {}\n): Promise<WebBrowserAuthSessionResult> {\n  if (_authSessionIsNativelySupported()) {\n    if (!NativeWebBrowser.openAuthSessionAsync) {\n      throw new UnavailabilityError('WebBrowser', 'openAuthSessionAsync');\n    }\n    if (['ios', 'web'].includes(Platform.OS)) {\n      return NativeWebBrowser.openAuthSessionAsync(url, redirectUrl, options);\n    }\n    return NativeWebBrowser.openAuthSessionAsync(url, redirectUrl);\n  } else {\n    return _openAuthSessionPolyfillAsync(url, redirectUrl, options);\n  }\n}\n\n// @docsMissing\nexport function dismissAuthSession(): void {\n  if (_authSessionIsNativelySupported()) {\n    if (!NativeWebBrowser.dismissAuthSession) {\n      throw new UnavailabilityError('WebBrowser', 'dismissAuthSession');\n    }\n    NativeWebBrowser.dismissAuthSession();\n  } else {\n    if (!NativeWebBrowser.dismissBrowser) {\n      throw new UnavailabilityError('WebBrowser', 'dismissAuthSession');\n    }\n    NativeWebBrowser.dismissBrowser();\n  }\n}\n\n/**\n * Possibly completes an authentication session on web in a window popup. The method\n * should be invoked on the page that the window redirects to.\n *\n * @param options\n *\n * @return Returns an object with message about why the redirect failed or succeeded:\n *\n * If `type` is set to `failed`, the reason depends on the message:\n * - `Not supported on this platform`: If the platform doesn't support this method (iOS, Android).\n * - `Cannot use expo-web-browser in a non-browser environment`: If the code was executed in an SSR\n *   or node environment.\n * - `No auth session is currently in progress`: (the cached state wasn't found in local storage).\n *   This can happen if the window redirects to an origin (website) that is different to the initial\n *   website origin. If this happens in development, it may be because the auth started on localhost\n *   and finished on your computer port (Ex: `128.0.0.*`). This is controlled by the `redirectUrl`\n *   and `returnUrl`.\n * - `Current URL \"<URL>\" and original redirect URL \"<URL>\" do not match`: This can occur when the\n *   redirect URL doesn't match what was initial defined as the `returnUrl`. You can skip this test\n *   in development by passing `{ skipRedirectCheck: true }` to the function.\n *\n * If `type` is set to `success`, the parent window will attempt to close the child window immediately.\n *\n * If the error `ERR_WEB_BROWSER_REDIRECT` was thrown, it may mean that the parent window was\n * reloaded before the auth was completed. In this case you'll need to close the child window manually.\n *\n * @platform web\n */\nexport function maybeCompleteAuthSession(\n  options: WebBrowserCompleteAuthSessionOptions = {}\n): WebBrowserCompleteAuthSessionResult {\n  if (NativeWebBrowser.maybeCompleteAuthSession) {\n    return NativeWebBrowser.maybeCompleteAuthSession(options);\n  }\n  return { type: 'failed', message: 'Not supported on this platform' };\n}\n\n/* iOS <= 10 and Android polyfill for SFAuthenticationSession flow */\n\nfunction _authSessionIsNativelySupported(): boolean {\n  if (Platform.OS === 'android') {\n    return false;\n  } else if (Platform.OS === 'web') {\n    return true;\n  }\n\n  const versionNumber = parseInt(String(Platform.Version), 10);\n  return versionNumber >= 11;\n}\n\nlet _redirectHandler: ((event: RedirectEvent) => void) | null = null;\n\n/*\n * openBrowserAsync on Android doesn't wait until closed, so we need to polyfill\n * it with AppState\n */\n\n// Store the `resolve` function from a Promise to fire when the AppState\n// returns to active\nlet _onWebBrowserCloseAndroid: null | (() => void) = null;\n\n// If the initial AppState.currentState is null, we assume that the first call to\n// AppState#change event is not actually triggered by a real change,\n// is triggered instead by the bridge capturing the current state\n// (https://reactnative.dev/docs/appstate#basic-usage)\nlet _isAppStateAvailable: boolean = AppState.currentState !== null;\nfunction _onAppStateChangeAndroid(state: AppStateStatus) {\n  if (!_isAppStateAvailable) {\n    _isAppStateAvailable = true;\n    return;\n  }\n\n  if (state === 'active' && _onWebBrowserCloseAndroid) {\n    _onWebBrowserCloseAndroid();\n  }\n}\n\nasync function _openBrowserAndWaitAndroidAsync(\n  startUrl: string,\n  browserParams: WebBrowserOpenOptions = {}\n): Promise<WebBrowserResult> {\n  const appStateChangedToActive = new Promise<void>((resolve) => {\n    _onWebBrowserCloseAndroid = resolve;\n  });\n  const stateChangeSubscription = AppState.addEventListener(\n    'change',\n    _onAppStateChangeAndroid\n  );\n\n  let result: WebBrowserResult = { type: WebBrowserResultType.CANCEL };\n  let type: string | null = null;\n\n  try {\n    ({ type } = await openBrowserAsync(startUrl, browserParams));\n  } catch (e) {\n    stateChangeSubscription?.remove();\n    _onWebBrowserCloseAndroid = null;\n    throw e;\n  }\n\n  if (type === 'opened') {\n    await appStateChangedToActive;\n    result = { type: WebBrowserResultType.DISMISS };\n  }\n\n  stateChangeSubscription?.remove();\n  _onWebBrowserCloseAndroid = null;\n  return result;\n}\n\nasync function _openAuthSessionPolyfillAsync(\n  startUrl: string,\n  returnUrl: string,\n  browserParams: WebBrowserOpenOptions = {}\n): Promise<WebBrowserAuthSessionResult> {\n  if (_redirectHandler) {\n    throw new Error(\n      `The WebBrowser's auth session is in an invalid state with a redirect handler set when it should not be`\n    );\n  }\n\n  if (_onWebBrowserCloseAndroid) {\n    throw new Error(\n      `WebBrowser is already open, only one can be open at a time`\n    );\n  }\n\n  try {\n    if (Platform.OS === 'android') {\n      return await Promise.race([\n        _openBrowserAndWaitAndroidAsync(startUrl, browserParams),\n        _waitForRedirectAsync(returnUrl),\n      ]);\n    } else {\n      return await Promise.race([\n        openBrowserAsync(startUrl, browserParams),\n        _waitForRedirectAsync(returnUrl),\n      ]);\n    }\n  } finally {\n    // We can't dismiss the browser on Android, only call this when it's available.\n    // Users on Android need to manually press the 'x' button in Chrome Custom Tabs, sadly.\n    if (NativeWebBrowser.dismissBrowser) {\n      NativeWebBrowser.dismissBrowser();\n    }\n\n    _stopWaitingForRedirect();\n  }\n}\n\nfunction _stopWaitingForRedirect() {\n  if (!_redirectHandler) {\n    throw new Error(\n      `The WebBrowser auth session is in an invalid state with no redirect handler when one should be set`\n    );\n  }\n\n  Linking.removeEventListener('url', _redirectHandler);\n  _redirectHandler = null;\n}\n\nfunction _waitForRedirectAsync(\n  returnUrl: string\n): Promise<WebBrowserRedirectResult> {\n  return new Promise((resolve) => {\n    _redirectHandler = (event: RedirectEvent) => {\n      if (event.url.startsWith(returnUrl)) {\n        resolve({ url: event.url, type: 'success' });\n      }\n    };\n\n    Linking.addEventListener('url', _redirectHandler);\n  });\n}\n"]}